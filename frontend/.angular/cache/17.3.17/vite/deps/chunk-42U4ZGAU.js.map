{
  "version": 3,
  "sources": ["../../../../../node_modules/rete-render-utils/rete-render-utils.esm.js", "../../../../../node_modules/@angular/elements/fesm2022/elements.mjs"],
  "sourcesContent": ["/*!\n* rete-render-utils v2.0.2\n* (c) 2024 Vitaliy Stoliarov\n* Released under the MIT license.\n* */\nimport _slicedToArray from '@babel/runtime/helpers/slicedToArray';\nimport _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';\nimport _classCallCheck from '@babel/runtime/helpers/classCallCheck';\nimport _createClass from '@babel/runtime/helpers/createClass';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport _regeneratorRuntime from '@babel/runtime/regenerator';\nimport { BaseAreaPlugin } from 'rete-area-plugin';\nimport _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport _possibleConstructorReturn from '@babel/runtime/helpers/possibleConstructorReturn';\nimport _getPrototypeOf from '@babel/runtime/helpers/getPrototypeOf';\nimport _inherits from '@babel/runtime/helpers/inherits';\n\n/**\n * Get classic SVG path for a connection between two points.\n * @param points Array of two points\n * @param curvature Curvature of the connection\n */\nfunction classicConnectionPath(points, curvature) {\n  var _points = _slicedToArray(points, 2),\n    _points$ = _points[0],\n    x1 = _points$.x,\n    y1 = _points$.y,\n    _points$2 = _points[1],\n    x2 = _points$2.x,\n    y2 = _points$2.y;\n  var vertical = Math.abs(y1 - y2);\n  var hx1 = x1 + Math.max(vertical / 2, Math.abs(x2 - x1)) * curvature;\n  var hx2 = x2 - Math.max(vertical / 2, Math.abs(x2 - x1)) * curvature;\n  return \"M \".concat(x1, \" \").concat(y1, \" C \").concat(hx1, \" \").concat(y1, \" \").concat(hx2, \" \").concat(y2, \" \").concat(x2, \" \").concat(y2);\n}\n\n/**\n * Get loop SVG path for a connection between two points.\n * @param points Array of two points\n * @param curvature Curvature of the loop\n * @param size Size of the loop\n */\nfunction loopConnectionPath(points, curvature, size) {\n  var _points2 = _slicedToArray(points, 2),\n    _points2$ = _points2[0],\n    x1 = _points2$.x,\n    y1 = _points2$.y,\n    _points2$2 = _points2[1],\n    x2 = _points2$2.x,\n    y2 = _points2$2.y;\n  var k = y2 > y1 ? 1 : -1;\n  var scale = size + Math.abs(x1 - x2) / (size / 2);\n  var middleX = (x1 + x2) / 2;\n  var middleY = y1 - k * scale;\n  var vertical = (y2 - y1) * curvature;\n  return \"\\n        M \".concat(x1, \" \").concat(y1, \"\\n        C \").concat(x1 + scale, \" \").concat(y1, \"\\n        \").concat(x1 + scale, \" \").concat(middleY - vertical, \"\\n        \").concat(middleX, \" \").concat(middleY, \"\\n        C \").concat(x2 - scale, \" \").concat(middleY + vertical, \"\\n        \").concat(x2 - scale, \" \").concat(y2, \"\\n        \").concat(x2, \" \").concat(y2, \"\\n    \");\n}\n\n/* eslint-disable max-statements */\n\n/**\n * Calculates the center coordinates of a child element relative to a parent element.\n * @async\n * @param child The child element whose center coordinates need to be calculated.\n * @param parent The parent element relative to which the child element's center is calculated.\n * @returns Position of the child element's center\n * @throws Error if the child element has a null offsetParent.\n */\nfunction getElementCenter(_x, _x2) {\n  return _getElementCenter.apply(this, arguments);\n}\nfunction _getElementCenter() {\n  _getElementCenter = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(child, parent) {\n    var x, y, currentElement, width, height;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          if (child.offsetParent) {\n            _context.next = 5;\n            break;\n          }\n          _context.next = 3;\n          return new Promise(function (res) {\n            return setTimeout(res, 0);\n          });\n        case 3:\n          _context.next = 0;\n          break;\n        case 5:\n          x = child.offsetLeft;\n          y = child.offsetTop;\n          currentElement = child.offsetParent;\n          if (currentElement) {\n            _context.next = 10;\n            break;\n          }\n          throw new Error('child has null offsetParent');\n        case 10:\n          while (currentElement !== null && currentElement !== parent) {\n            x += currentElement.offsetLeft + currentElement.clientLeft;\n            y += currentElement.offsetTop + currentElement.clientTop;\n            currentElement = currentElement.offsetParent;\n          }\n          width = child.offsetWidth;\n          height = child.offsetHeight;\n          return _context.abrupt(\"return\", {\n            x: x + width / 2,\n            y: y + height / 2\n          });\n        case 14:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _getElementCenter.apply(this, arguments);\n}\nvar EventEmitter = /*#__PURE__*/function () {\n  function EventEmitter() {\n    _classCallCheck(this, EventEmitter);\n    _defineProperty(this, \"listeners\", new Set());\n  }\n  return _createClass(EventEmitter, [{\n    key: \"emit\",\n    value: function emit(data) {\n      this.listeners.forEach(function (listener) {\n        listener(data);\n      });\n    }\n  }, {\n    key: \"listen\",\n    value: function listen(handler) {\n      var _this = this;\n      this.listeners.add(handler);\n      return function () {\n        _this.listeners[\"delete\"](handler);\n      };\n    }\n  }]);\n}();\n\nvar SocketsPositionsStorage = /*#__PURE__*/function () {\n  function SocketsPositionsStorage() {\n    _classCallCheck(this, SocketsPositionsStorage);\n    _defineProperty(this, \"elements\", new Map());\n  }\n  return _createClass(SocketsPositionsStorage, [{\n    key: \"getPosition\",\n    value: function getPosition(data) {\n      var _found$pop$position, _found$pop;\n      var list = Array.from(this.elements.values()).flat();\n      var found = list.filter(function (item) {\n        return item.side === data.side && item.nodeId === data.nodeId && item.key === data.key;\n      });\n\n      // eslint-disable-next-line no-console\n      if (found.length > 1) console.warn(['Found more than one element for socket with same key and side.', 'Probably it was not unmounted correctly'].join(' '), data);\n      return (_found$pop$position = (_found$pop = found.pop()) === null || _found$pop === void 0 ? void 0 : _found$pop.position) !== null && _found$pop$position !== void 0 ? _found$pop$position : null;\n    }\n  }, {\n    key: \"add\",\n    value: function add(data) {\n      var existing = this.elements.get(data.element);\n      this.elements.set(data.element, existing ? [].concat(_toConsumableArray(existing.filter(function (n) {\n        return !(n.nodeId === data.nodeId && n.key === data.key && n.side === data.side);\n      })), [data]) : [data]);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(element) {\n      this.elements[\"delete\"](element);\n    }\n  }, {\n    key: \"snapshot\",\n    value: function snapshot() {\n      return Array.from(this.elements.values()).flat();\n    }\n  }]);\n}();\n\n/**\n * Abstract class for socket position calculation. It can be extended to implement custom socket position calculation.\n * @abstract\n * @listens render\n * @listens rendered\n * @listens unmount\n * @listens nodetranslated\n * @listens noderesized\n */\nvar BaseSocketPosition = /*#__PURE__*/function () {\n  function BaseSocketPosition() {\n    _classCallCheck(this, BaseSocketPosition);\n    _defineProperty(this, \"sockets\", new SocketsPositionsStorage());\n    _defineProperty(this, \"emitter\", new EventEmitter());\n    _defineProperty(this, \"area\", null);\n  }\n  return _createClass(BaseSocketPosition, [{\n    key: \"attach\",\n    value:\n    /**\n     * Attach the watcher to the area's child scope.\n     * @param scope Scope of the watcher that should be a child of `BaseAreaPlugin`\n     */\n    function attach(scope) {\n      var _this = this;\n      if (this.area) return;\n      if (!scope.hasParent()) return;\n      this.area = scope.parentScope(BaseAreaPlugin);\n\n      // eslint-disable-next-line max-statements\n      this.area.addPipe(/*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(context) {\n          var _context$data, _nodeId, _key, _side, _element, position, _nodeId2, _context$data$payload, source, target, _nodeId3;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(context.type === 'rendered' && context.data.type === 'socket')) {\n                  _context2.next = 8;\n                  break;\n                }\n                _context$data = context.data, _nodeId = _context$data.nodeId, _key = _context$data.key, _side = _context$data.side, _element = _context$data.element;\n                _context2.next = 4;\n                return _this.calculatePosition(_nodeId, _side, _key, _element);\n              case 4:\n                position = _context2.sent;\n                if (position) {\n                  _this.sockets.add({\n                    nodeId: _nodeId,\n                    key: _key,\n                    side: _side,\n                    element: _element,\n                    position: position\n                  });\n                  _this.emitter.emit({\n                    nodeId: _nodeId,\n                    key: _key,\n                    side: _side\n                  });\n                }\n                _context2.next = 24;\n                break;\n              case 8:\n                if (!(context.type === 'unmount')) {\n                  _context2.next = 12;\n                  break;\n                }\n                _this.sockets.remove(context.data.element);\n                _context2.next = 24;\n                break;\n              case 12:\n                if (!(context.type === 'nodetranslated')) {\n                  _context2.next = 16;\n                  break;\n                }\n                _this.emitter.emit({\n                  nodeId: context.data.id\n                });\n                _context2.next = 24;\n                break;\n              case 16:\n                if (!(context.type === 'noderesized')) {\n                  _context2.next = 23;\n                  break;\n                }\n                _nodeId2 = context.data.id;\n                _context2.next = 20;\n                return Promise.all(_this.sockets.snapshot().filter(function (item) {\n                  return item.nodeId === context.data.id && item.side === 'output';\n                }).map(/*#__PURE__*/function () {\n                  var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(item) {\n                    var side, key, element, position;\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) switch (_context.prev = _context.next) {\n                        case 0:\n                          side = item.side, key = item.key, element = item.element;\n                          _context.next = 3;\n                          return _this.calculatePosition(_nodeId2, side, key, element);\n                        case 3:\n                          position = _context.sent;\n                          if (position) {\n                            item.position = position;\n                          }\n                        case 5:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }, _callee);\n                  }));\n                  return function (_x2) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }()));\n              case 20:\n                _this.emitter.emit({\n                  nodeId: _nodeId2\n                });\n                _context2.next = 24;\n                break;\n              case 23:\n                if (context.type === 'render' && context.data.type === 'connection') {\n                  _context$data$payload = context.data.payload, source = _context$data$payload.source, target = _context$data$payload.target;\n                  _nodeId3 = source || target;\n                  _this.emitter.emit({\n                    nodeId: _nodeId3\n                  });\n                }\n              case 24:\n                return _context2.abrupt(\"return\", context);\n              case 25:\n              case \"end\":\n                return _context2.stop();\n            }\n          }, _callee2);\n        }));\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    }\n\n    /**\n     * Listen to socket position changes. Usually used by rendering plugins to update the start/end of the connection.\n     * @internal\n     * @param nodeId Node ID\n     * @param side Side of the socket, 'input' or 'output'\n     * @param key Socket key\n     * @param change Callback function that is called when the socket position changes\n     */\n  }, {\n    key: \"listen\",\n    value: function listen(nodeId, side, key, change) {\n      var _this2 = this;\n      var unlisten = this.emitter.listen(function (data) {\n        if (data.nodeId !== nodeId) return;\n        if ((!data.key || data.side === side) && (!data.side || data.key === key)) {\n          var _this2$area;\n          var position = _this2.sockets.getPosition({\n            side: side,\n            nodeId: nodeId,\n            key: key\n          });\n          if (!position) return;\n          var x = position.x,\n            y = position.y;\n          var nodeView = (_this2$area = _this2.area) === null || _this2$area === void 0 ? void 0 : _this2$area.nodeViews.get(nodeId);\n          if (nodeView) change({\n            x: x + nodeView.position.x,\n            y: y + nodeView.position.y\n          });\n        }\n      });\n      this.sockets.snapshot().forEach(function (data) {\n        if (data.nodeId === nodeId) _this2.emitter.emit(data);\n      });\n      return unlisten;\n    }\n  }]);\n}();\n\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\n\n/**\n * Props for `DOMSocketPosition` class.\n */\n\n/**\n * Class for socket position calculation based on DOM elements. It uses `getElementCenter` function to calculate the position.\n */\nvar DOMSocketPosition = /*#__PURE__*/function (_BaseSocketPosition) {\n  function DOMSocketPosition(props) {\n    var _this;\n    _classCallCheck(this, DOMSocketPosition);\n    _this = _callSuper(this, DOMSocketPosition);\n    _this.props = props;\n    return _this;\n  }\n  _inherits(DOMSocketPosition, _BaseSocketPosition);\n  return _createClass(DOMSocketPosition, [{\n    key: \"calculatePosition\",\n    value: function () {\n      var _calculatePosition = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(nodeId, side, key, element) {\n        var _this$area, _this$props;\n        var view, position;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              view = (_this$area = this.area) === null || _this$area === void 0 ? void 0 : _this$area.nodeViews.get(nodeId);\n              if (view !== null && view !== void 0 && view.element) {\n                _context.next = 3;\n                break;\n              }\n              return _context.abrupt(\"return\", null);\n            case 3:\n              _context.next = 5;\n              return getElementCenter(element, view.element);\n            case 5:\n              position = _context.sent;\n              if (!((_this$props = this.props) !== null && _this$props !== void 0 && _this$props.offset)) {\n                _context.next = 8;\n                break;\n              }\n              return _context.abrupt(\"return\", this.props.offset(position, nodeId, side, key));\n            case 8:\n              return _context.abrupt(\"return\", {\n                x: position.x + 12 * (side === 'input' ? -1 : 1),\n                y: position.y\n              });\n            case 9:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function calculatePosition(_x, _x2, _x3, _x4) {\n        return _calculatePosition.apply(this, arguments);\n      }\n      return calculatePosition;\n    }()\n  }]);\n}(BaseSocketPosition);\n\n/**\n * Wrapper function for `DOMSocketPosition` class.\n * @param props Props for `DOMSocketPosition` class\n */\nfunction getDOMSocketPosition(props) {\n  return new DOMSocketPosition(props);\n}\n\nexport { BaseSocketPosition, DOMSocketPosition, classicConnectionPath, getDOMSocketPosition, getElementCenter, loopConnectionPath };\n\n", "/**\n * @license Angular v17.3.12\n * (c) 2010-2024 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { ComponentFactoryResolver, NgZone, Injector, ChangeDetectorRef, ApplicationRef, SimpleChange, Version } from '@angular/core';\nimport { ReplaySubject, merge } from 'rxjs';\nimport { switchMap, map } from 'rxjs/operators';\n\n/**\n * Provide methods for scheduling the execution of a callback.\n */\nconst scheduler = {\n    /**\n     * Schedule a callback to be called after some delay.\n     *\n     * Returns a function that when executed will cancel the scheduled function.\n     */\n    schedule(taskFn, delay) {\n        const id = setTimeout(taskFn, delay);\n        return () => clearTimeout(id);\n    },\n    /**\n     * Schedule a callback to be called before the next render.\n     * (If `window.requestAnimationFrame()` is not available, use `scheduler.schedule()` instead.)\n     *\n     * Returns a function that when executed will cancel the scheduled function.\n     */\n    scheduleBeforeRender(taskFn) {\n        // TODO(gkalpak): Implement a better way of accessing `requestAnimationFrame()`\n        //                (e.g. accounting for vendor prefix, SSR-compatibility, etc).\n        if (typeof window === 'undefined') {\n            // For SSR just schedule immediately.\n            return scheduler.schedule(taskFn, 0);\n        }\n        if (typeof window.requestAnimationFrame === 'undefined') {\n            const frameMs = 16;\n            return scheduler.schedule(taskFn, frameMs);\n        }\n        const id = window.requestAnimationFrame(taskFn);\n        return () => window.cancelAnimationFrame(id);\n    },\n};\n/**\n * Convert a camelCased string to kebab-cased.\n */\nfunction camelToDashCase(input) {\n    return input.replace(/[A-Z]/g, (char) => `-${char.toLowerCase()}`);\n}\n/**\n * Check whether the input is an `Element`.\n */\nfunction isElement(node) {\n    return !!node && node.nodeType === Node.ELEMENT_NODE;\n}\n/**\n * Check whether the input is a function.\n */\nfunction isFunction(value) {\n    return typeof value === 'function';\n}\n/**\n * Convert a kebab-cased string to camelCased.\n */\nfunction kebabToCamelCase(input) {\n    return input.replace(/-([a-z\\d])/g, (_, char) => char.toUpperCase());\n}\nlet _matches;\n/**\n * Check whether an `Element` matches a CSS selector.\n * NOTE: this is duplicated from @angular/upgrade, and can\n * be consolidated in the future\n */\nfunction matchesSelector(el, selector) {\n    if (!_matches) {\n        const elProto = Element.prototype;\n        _matches =\n            elProto.matches ||\n                elProto.matchesSelector ||\n                elProto.mozMatchesSelector ||\n                elProto.msMatchesSelector ||\n                elProto.oMatchesSelector ||\n                elProto.webkitMatchesSelector;\n    }\n    return el.nodeType === Node.ELEMENT_NODE ? _matches.call(el, selector) : false;\n}\n/**\n * Test two values for strict equality, accounting for the fact that `NaN !== NaN`.\n */\nfunction strictEquals(value1, value2) {\n    return value1 === value2 || (value1 !== value1 && value2 !== value2);\n}\n/** Gets a map of default set of attributes to observe and the properties they affect. */\nfunction getDefaultAttributeToPropertyInputs(inputs) {\n    const attributeToPropertyInputs = {};\n    inputs.forEach(({ propName, templateName, transform }) => {\n        attributeToPropertyInputs[camelToDashCase(templateName)] = [propName, transform];\n    });\n    return attributeToPropertyInputs;\n}\n/**\n * Gets a component's set of inputs. Uses the injector to get the component factory where the inputs\n * are defined.\n */\nfunction getComponentInputs(component, injector) {\n    const componentFactoryResolver = injector.get(ComponentFactoryResolver);\n    const componentFactory = componentFactoryResolver.resolveComponentFactory(component);\n    return componentFactory.inputs;\n}\n\n// NOTE: This is a (slightly improved) version of what is used in ngUpgrade's\nfunction extractProjectableNodes(host, ngContentSelectors) {\n    const nodes = host.childNodes;\n    const projectableNodes = ngContentSelectors.map(() => []);\n    let wildcardIndex = -1;\n    ngContentSelectors.some((selector, i) => {\n        if (selector === '*') {\n            wildcardIndex = i;\n            return true;\n        }\n        return false;\n    });\n    for (let i = 0, ii = nodes.length; i < ii; ++i) {\n        const node = nodes[i];\n        const ngContentIndex = findMatchingIndex(node, ngContentSelectors, wildcardIndex);\n        if (ngContentIndex !== -1) {\n            projectableNodes[ngContentIndex].push(node);\n        }\n    }\n    return projectableNodes;\n}\nfunction findMatchingIndex(node, selectors, defaultIndex) {\n    let matchingIndex = defaultIndex;\n    if (isElement(node)) {\n        selectors.some((selector, i) => {\n            if (selector !== '*' && matchesSelector(node, selector)) {\n                matchingIndex = i;\n                return true;\n            }\n            return false;\n        });\n    }\n    return matchingIndex;\n}\n\n/** Time in milliseconds to wait before destroying the component ref when disconnected. */\nconst DESTROY_DELAY = 10;\n/**\n * Factory that creates new ComponentNgElementStrategy instance. Gets the component factory with the\n * constructor's injector's factory resolver and passes that factory to each strategy.\n */\nclass ComponentNgElementStrategyFactory {\n    constructor(component, injector) {\n        this.componentFactory = injector\n            .get(ComponentFactoryResolver)\n            .resolveComponentFactory(component);\n    }\n    create(injector) {\n        return new ComponentNgElementStrategy(this.componentFactory, injector);\n    }\n}\n/**\n * Creates and destroys a component ref using a component factory and handles change detection\n * in response to input changes.\n */\nclass ComponentNgElementStrategy {\n    constructor(componentFactory, injector) {\n        this.componentFactory = componentFactory;\n        this.injector = injector;\n        // Subject of `NgElementStrategyEvent` observables corresponding to the component's outputs.\n        this.eventEmitters = new ReplaySubject(1);\n        /** Merged stream of the component's output events. */\n        this.events = this.eventEmitters.pipe(switchMap((emitters) => merge(...emitters)));\n        /** Reference to the component that was created on connect. */\n        this.componentRef = null;\n        /** Reference to the component view's `ChangeDetectorRef`. */\n        this.viewChangeDetectorRef = null;\n        /**\n         * Changes that have been made to component inputs since the last change detection run.\n         * (NOTE: These are only recorded if the component implements the `OnChanges` interface.)\n         */\n        this.inputChanges = null;\n        /** Whether changes have been made to component inputs since the last change detection run. */\n        this.hasInputChanges = false;\n        /** Whether the created component implements the `OnChanges` interface. */\n        this.implementsOnChanges = false;\n        /** Whether a change detection has been scheduled to run on the component. */\n        this.scheduledChangeDetectionFn = null;\n        /** Callback function that when called will cancel a scheduled destruction on the component. */\n        this.scheduledDestroyFn = null;\n        /** Initial input values that were set before the component was created. */\n        this.initialInputValues = new Map();\n        this.unchangedInputs = new Set(this.componentFactory.inputs.map(({ propName }) => propName));\n        this.ngZone = this.injector.get(NgZone);\n        this.elementZone = typeof Zone === 'undefined' ? null : this.ngZone.run(() => Zone.current);\n    }\n    /**\n     * Initializes a new component if one has not yet been created and cancels any scheduled\n     * destruction.\n     */\n    connect(element) {\n        this.runInZone(() => {\n            // If the element is marked to be destroyed, cancel the task since the component was\n            // reconnected\n            if (this.scheduledDestroyFn !== null) {\n                this.scheduledDestroyFn();\n                this.scheduledDestroyFn = null;\n                return;\n            }\n            if (this.componentRef === null) {\n                this.initializeComponent(element);\n            }\n        });\n    }\n    /**\n     * Schedules the component to be destroyed after some small delay in case the element is just\n     * being moved across the DOM.\n     */\n    disconnect() {\n        this.runInZone(() => {\n            // Return if there is no componentRef or the component is already scheduled for destruction\n            if (this.componentRef === null || this.scheduledDestroyFn !== null) {\n                return;\n            }\n            // Schedule the component to be destroyed after a small timeout in case it is being\n            // moved elsewhere in the DOM\n            this.scheduledDestroyFn = scheduler.schedule(() => {\n                if (this.componentRef !== null) {\n                    this.componentRef.destroy();\n                    this.componentRef = null;\n                    this.viewChangeDetectorRef = null;\n                }\n            }, DESTROY_DELAY);\n        });\n    }\n    /**\n     * Returns the component property value. If the component has not yet been created, the value is\n     * retrieved from the cached initialization values.\n     */\n    getInputValue(property) {\n        return this.runInZone(() => {\n            if (this.componentRef === null) {\n                return this.initialInputValues.get(property);\n            }\n            return this.componentRef.instance[property];\n        });\n    }\n    /**\n     * Sets the input value for the property. If the component has not yet been created, the value is\n     * cached and set when the component is created.\n     */\n    setInputValue(property, value, transform) {\n        this.runInZone(() => {\n            if (transform) {\n                value = transform.call(this.componentRef?.instance, value);\n            }\n            if (this.componentRef === null) {\n                this.initialInputValues.set(property, value);\n                return;\n            }\n            // Ignore the value if it is strictly equal to the current value, except if it is `undefined`\n            // and this is the first change to the value (because an explicit `undefined` _is_ strictly\n            // equal to not having a value set at all, but we still need to record this as a change).\n            if (strictEquals(value, this.getInputValue(property)) &&\n                !(value === undefined && this.unchangedInputs.has(property))) {\n                return;\n            }\n            // Record the changed value and update internal state to reflect the fact that this input has\n            // changed.\n            this.recordInputChange(property, value);\n            this.unchangedInputs.delete(property);\n            this.hasInputChanges = true;\n            // Update the component instance and schedule change detection.\n            this.componentRef.instance[property] = value;\n            this.scheduleDetectChanges();\n        });\n    }\n    /**\n     * Creates a new component through the component factory with the provided element host and\n     * sets up its initial inputs, listens for outputs changes, and runs an initial change detection.\n     */\n    initializeComponent(element) {\n        const childInjector = Injector.create({ providers: [], parent: this.injector });\n        const projectableNodes = extractProjectableNodes(element, this.componentFactory.ngContentSelectors);\n        this.componentRef = this.componentFactory.create(childInjector, projectableNodes, element);\n        this.viewChangeDetectorRef = this.componentRef.injector.get(ChangeDetectorRef);\n        this.implementsOnChanges = isFunction(this.componentRef.instance.ngOnChanges);\n        this.initializeInputs();\n        this.initializeOutputs(this.componentRef);\n        this.detectChanges();\n        const applicationRef = this.injector.get(ApplicationRef);\n        applicationRef.attachView(this.componentRef.hostView);\n    }\n    /** Set any stored initial inputs on the component's properties. */\n    initializeInputs() {\n        this.componentFactory.inputs.forEach(({ propName, transform }) => {\n            if (this.initialInputValues.has(propName)) {\n                // Call `setInputValue()` now that the component has been instantiated to update its\n                // properties and fire `ngOnChanges()`.\n                this.setInputValue(propName, this.initialInputValues.get(propName), transform);\n            }\n        });\n        this.initialInputValues.clear();\n    }\n    /** Sets up listeners for the component's outputs so that the events stream emits the events. */\n    initializeOutputs(componentRef) {\n        const eventEmitters = this.componentFactory.outputs.map(({ propName, templateName }) => {\n            const emitter = componentRef.instance[propName];\n            return emitter.pipe(map((value) => ({ name: templateName, value })));\n        });\n        this.eventEmitters.next(eventEmitters);\n    }\n    /** Calls ngOnChanges with all the inputs that have changed since the last call. */\n    callNgOnChanges(componentRef) {\n        if (!this.implementsOnChanges || this.inputChanges === null) {\n            return;\n        }\n        // Cache the changes and set inputChanges to null to capture any changes that might occur\n        // during ngOnChanges.\n        const inputChanges = this.inputChanges;\n        this.inputChanges = null;\n        componentRef.instance.ngOnChanges(inputChanges);\n    }\n    /**\n     * Marks the component view for check, if necessary.\n     * (NOTE: This is required when the `ChangeDetectionStrategy` is set to `OnPush`.)\n     */\n    markViewForCheck(viewChangeDetectorRef) {\n        if (this.hasInputChanges) {\n            this.hasInputChanges = false;\n            viewChangeDetectorRef.markForCheck();\n        }\n    }\n    /**\n     * Schedules change detection to run on the component.\n     * Ignores subsequent calls if already scheduled.\n     */\n    scheduleDetectChanges() {\n        if (this.scheduledChangeDetectionFn) {\n            return;\n        }\n        this.scheduledChangeDetectionFn = scheduler.scheduleBeforeRender(() => {\n            this.scheduledChangeDetectionFn = null;\n            this.detectChanges();\n        });\n    }\n    /**\n     * Records input changes so that the component receives SimpleChanges in its onChanges function.\n     */\n    recordInputChange(property, currentValue) {\n        // Do not record the change if the component does not implement `OnChanges`.\n        if (!this.implementsOnChanges) {\n            return;\n        }\n        if (this.inputChanges === null) {\n            this.inputChanges = {};\n        }\n        // If there already is a change, modify the current value to match but leave the values for\n        // `previousValue` and `isFirstChange`.\n        const pendingChange = this.inputChanges[property];\n        if (pendingChange) {\n            pendingChange.currentValue = currentValue;\n            return;\n        }\n        const isFirstChange = this.unchangedInputs.has(property);\n        const previousValue = isFirstChange ? undefined : this.getInputValue(property);\n        this.inputChanges[property] = new SimpleChange(previousValue, currentValue, isFirstChange);\n    }\n    /** Runs change detection on the component. */\n    detectChanges() {\n        if (this.componentRef === null) {\n            return;\n        }\n        this.callNgOnChanges(this.componentRef);\n        this.markViewForCheck(this.viewChangeDetectorRef);\n        this.componentRef.changeDetectorRef.detectChanges();\n    }\n    /** Runs in the angular zone, if present. */\n    runInZone(fn) {\n        return this.elementZone && Zone.current !== this.elementZone ? this.ngZone.run(fn) : fn();\n    }\n}\n\n/**\n * Implements the functionality needed for a custom element.\n *\n * @publicApi\n */\nclass NgElement extends HTMLElement {\n    constructor() {\n        super(...arguments);\n        /**\n         * A subscription to change, connect, and disconnect events in the custom element.\n         */\n        this.ngElementEventsSubscription = null;\n    }\n}\n/**\n *  @description Creates a custom element class based on an Angular component.\n *\n * Builds a class that encapsulates the functionality of the provided component and\n * uses the configuration information to provide more context to the class.\n * Takes the component factory's inputs and outputs to convert them to the proper\n * custom element API and add hooks to input changes.\n *\n * The configuration's injector is the initial injector set on the class,\n * and used by default for each created instance.This behavior can be overridden with the\n * static property to affect all newly created instances, or as a constructor argument for\n * one-off creations.\n *\n * @see [Angular Elements Overview](guide/elements \"Turning Angular components into custom elements\")\n *\n * @param component The component to transform.\n * @param config A configuration that provides initialization information to the created class.\n * @returns The custom-element construction class, which can be registered with\n * a browser's `CustomElementRegistry`.\n *\n * @publicApi\n */\nfunction createCustomElement(component, config) {\n    const inputs = getComponentInputs(component, config.injector);\n    const strategyFactory = config.strategyFactory || new ComponentNgElementStrategyFactory(component, config.injector);\n    const attributeToPropertyInputs = getDefaultAttributeToPropertyInputs(inputs);\n    class NgElementImpl extends NgElement {\n        // Work around a bug in closure typed optimizations(b/79557487) where it is not honoring static\n        // field externs. So using quoted access to explicitly prevent renaming.\n        static { this['observedAttributes'] = Object.keys(attributeToPropertyInputs); }\n        get ngElementStrategy() {\n            // TODO(andrewseguin): Add e2e tests that cover cases where the constructor isn't called. For\n            // now this is tested using a Google internal test suite.\n            if (!this._ngElementStrategy) {\n                const strategy = (this._ngElementStrategy = strategyFactory.create(this.injector || config.injector));\n                // Re-apply pre-existing input values (set as properties on the element) through the\n                // strategy.\n                inputs.forEach(({ propName, transform }) => {\n                    if (!this.hasOwnProperty(propName)) {\n                        // No pre-existing value for `propName`.\n                        return;\n                    }\n                    // Delete the property from the instance and re-apply it through the strategy.\n                    const value = this[propName];\n                    delete this[propName];\n                    strategy.setInputValue(propName, value, transform);\n                });\n            }\n            return this._ngElementStrategy;\n        }\n        constructor(injector) {\n            super();\n            this.injector = injector;\n        }\n        attributeChangedCallback(attrName, oldValue, newValue, namespace) {\n            const [propName, transform] = attributeToPropertyInputs[attrName];\n            this.ngElementStrategy.setInputValue(propName, newValue, transform);\n        }\n        connectedCallback() {\n            // For historical reasons, some strategies may not have initialized the `events` property\n            // until after `connect()` is run. Subscribe to `events` if it is available before running\n            // `connect()` (in order to capture events emitted during initialization), otherwise subscribe\n            // afterwards.\n            //\n            // TODO: Consider deprecating/removing the post-connect subscription in a future major version\n            //       (e.g. v11).\n            let subscribedToEvents = false;\n            if (this.ngElementStrategy.events) {\n                // `events` are already available: Subscribe to it asap.\n                this.subscribeToEvents();\n                subscribedToEvents = true;\n            }\n            this.ngElementStrategy.connect(this);\n            if (!subscribedToEvents) {\n                // `events` were not initialized before running `connect()`: Subscribe to them now.\n                // The events emitted during the component initialization have been missed, but at least\n                // future events will be captured.\n                this.subscribeToEvents();\n            }\n        }\n        disconnectedCallback() {\n            // Not using `this.ngElementStrategy` to avoid unnecessarily creating the `NgElementStrategy`.\n            if (this._ngElementStrategy) {\n                this._ngElementStrategy.disconnect();\n            }\n            if (this.ngElementEventsSubscription) {\n                this.ngElementEventsSubscription.unsubscribe();\n                this.ngElementEventsSubscription = null;\n            }\n        }\n        subscribeToEvents() {\n            // Listen for events from the strategy and dispatch them as custom events.\n            this.ngElementEventsSubscription = this.ngElementStrategy.events.subscribe((e) => {\n                const customEvent = new CustomEvent(e.name, { detail: e.value });\n                this.dispatchEvent(customEvent);\n            });\n        }\n    }\n    // Add getters and setters to the prototype for each property input.\n    inputs.forEach(({ propName, transform }) => {\n        Object.defineProperty(NgElementImpl.prototype, propName, {\n            get() {\n                return this.ngElementStrategy.getInputValue(propName);\n            },\n            set(newValue) {\n                this.ngElementStrategy.setInputValue(propName, newValue, transform);\n            },\n            configurable: true,\n            enumerable: true,\n        });\n    });\n    return NgElementImpl;\n}\n\n/**\n * @publicApi\n */\nconst VERSION = new Version('17.3.12');\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of the `elements` package.\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n// This file is not used to build this module. It is only used during editing\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NgElement, VERSION, createCustomElement };\n\n"],
  "mappings": "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",
  "names": ["_regeneratorRuntime", "EventEmitter", "SocketsPositionsStorage", "BaseSocketPosition", "position", "t", "_isNativeReflectConstruct", "DOMSocketPosition"]
}
